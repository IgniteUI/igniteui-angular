import { AfterViewInit, ChangeDetectorRef, Component, DebugElement, Injectable, OnInit, ViewChild } from '@angular/core';
import { async, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { BehaviorSubject, Observable } from 'rxjs';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { IgxGridAPIService } from './api.service';
import { IgxGridComponent } from './grid.component';
import { IgxColumnComponent } from './column.component';
import { IForOfState } from '../directives/for-of/for_of.directive';
import { IgxGridModule } from './index';
import { IgxNumberFilteringOperand } from '../../public_api';
import { DisplayDensity } from '../core/utils';
import { DataType } from '../data-operations/data-util';
import { GridTemplateStrings } from '../test-utils/template-strings.spec';
import { SampleTestData } from '../test-utils/sample-test-data.spec';
import { BasicGridComponent } from '../test-utils/grid-base-components.spec';
import { UIInteractions, wait } from '../test-utils/ui-interactions.spec';
import {
    IgxRowEditTemplateDirective,
    IgxRowEditTabStopDirective
} from './grid.rowEdit.directive';
import { IgxGridRowComponent } from './row.component';
import { IgxStringFilteringOperand } from '../data-operations/filtering-condition';
import { SortingDirection } from '../data-operations/sorting-expression.interface';

const DEBOUNCETIME = 30;

describe('IgxGrid Component Tests', () => {
    const MIN_COL_WIDTH = '136px';
    const COLUMN_HEADER_CLASS = '.igx-grid__th';
    const CELL_CLASS = '.igx-grid__td';
    const ROW_CLASS = '.igx-grid__tr';
    const ROW_EDITING_OUTLET_CLASS = '.igx-grid__row-editing-outlet';

    describe('IgxGrid - input properties', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridTestComponent,
                    IgxGridMarkupDeclarationComponent,
                    IgxGridRemoteVirtualizationComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should initialize a grid with columns from markup', () => {
            const fix = TestBed.createComponent(IgxGridMarkupDeclarationComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.instance;
            const domGrid = fix.debugElement.query(By.css('igx-grid')).nativeElement;

            expect(grid).toBeDefined('Grid initializing through markup failed');
            expect(grid.columnList.length).toEqual(2, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(3, 'Invalid number of rows initialized');

            expect(grid.id).toContain('igx-grid-');
            expect(domGrid.id).toContain('igx-grid-');

            grid.id = 'customGridId';
            fix.detectChanges();

            expect(grid.id).toBe('customGridId');
            expect(domGrid.id).toBe('customGridId');
            expect(fix.componentInstance.columnEventCount).toEqual(2);
        });

        it('should initialize a grid with autogenerated columns', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.data = [
                { Number: 1, String: '1', Boolean: true, Date: new Date(Date.now()) }
            ];
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid).toBeDefined('Grid initializing through autoGenerate failed');
            expect(grid.columnList.length).toEqual(4, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(1, 'Invalid number of rows initialized');
            expect(grid.columnList.first.dataType).toEqual(DataType.Number, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 1).dataType)
                .toEqual(DataType.String, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 2).dataType)
                .toEqual(DataType.Boolean, 'Invalid dataType set on column');
            expect(grid.columnList.last.dataType).toEqual(DataType.Date, 'Invalid dataType set on column');
            expect(fix.componentInstance.columnEventCount).toEqual(4);
        });

        it('should initialize a grid and change column properties during initialization', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            grid.columnList.forEach((column) => {
                expect(column.filterable).toEqual(true);
                expect(column.sortable).toEqual(true);
            });
        });

        it('should initialize grid with remove virtualization', (done) => {
            const fix = TestBed.createComponent(IgxGridRemoteVirtualizationComponent);
            fix.detectChanges();
            let rows = fix.componentInstance.instance.rowList.toArray();
            expect(rows.length).toEqual(10);

            const verticalScroll = fix.componentInstance.instance.verticalScrollContainer;
            const elem = verticalScroll['vh'].instance.elementRef.nativeElement;

            // scroll down
            expect(() => {
                elem.scrollTop = 1000;
                fix.detectChanges();
                fix.componentRef.hostView.detectChanges();
            }).not.toThrow();

            setTimeout(() => {
                fix.detectChanges();
                fix.componentInstance.cdr.detectChanges();
                rows = fix.componentInstance.instance.rowList.toArray();
                const data = fix.componentInstance.data.source.getValue();
                for (let i = fix.componentInstance.instance.virtualizationState.startIndex; i < rows.length; i++) {
                    expect(rows[i].rowData['Col1'])
                        .toBe(data[i]['Col1']);
                }
                done();
            }, 500);
        });

        it('height/width should be calculated depending on number of records', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const gridBody = fix.debugElement.query(By.css('.igx-grid__tbody'));
            const gridHeader = fix.debugElement.query(By.css('.igx-grid__thead'));
            const gridFooter = fix.debugElement.query(By.css('.igx-grid__tfoot'));
            const gridScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            let gridBodyHeight;
            let verticalScrollHeight;

            fix.detectChanges();

            expect(grid.rowList.length).toEqual(1);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('50px');

            for (let i = 2; i <= 30; i++) {
                grid.addRow({ index: i, value: i });
            }

            fix.detectChanges();

            expect(grid.rowList.length).toEqual(30);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('1500px');
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(false);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);
            grid.height = '200px';
            fix.detectChanges();

            tick(200);
            fix.detectChanges();
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);
            verticalScrollHeight = fix.componentInstance.getVerticalScrollHeight();
            grid.width = '200px';

            tick(200);
            fix.detectChanges();
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.getVerticalScrollHeight()).toBeLessThan(verticalScrollHeight);
            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridScroll.nativeElement).height, 10);

            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('200px');
            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('200px');
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);
            grid.height = '50%';
            fix.detectChanges();
            tick(200);
            fix.detectChanges();

            grid.width = '50%';
            fix.detectChanges();
            tick(200);
            fix.detectChanges();

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');

            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10);

            // The scrollbar is no longer visible
            //    - parseInt(window.getComputedStyle(gridScroll.nativeElement).height, 10);
            // console.log(gridBodyHeight);
            // console.log(window.getComputedStyle(gridBody.nativeElement).height);
            // console.log(gridBodyHeight === parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10));
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);
        }));

        it('should not have column misalignment when no vertical scrollbar is shown', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const gridBody = fix.debugElement.query(By.css('.igx-grid__tbody'));
            const gridHeader = fix.debugElement.query(By.css('.igx-grid__thead'));

            expect(window.getComputedStyle(gridBody.children[0].nativeElement).width).toEqual(
                window.getComputedStyle(gridHeader.children[0].nativeElement).width
            );
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should change displayDensity runtime correctly', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.columns[1].hasSummary = true;
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;
            const headerHight = fixture.debugElement.query(By.css('.igx-grid__thead')).query(By.css('.igx-grid__tr')).nativeElement;
            const rowHeight = fixture.debugElement.query(By.css('.igx-grid__tbody')).query(By.css('.igx-grid__tr')).nativeElement;
            const summaryItemHeigh = fixture.debugElement.query(By.css('.igx-grid__tfoot'))
                .query(By.css('.igx-grid-summary__item')).nativeElement;

            expect(grid.defaultRowHeight).toBe(50);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
            grid.displayDensity = 'cosy';
            fixture.detectChanges();
            tick(100);
            expect(grid.nativeElement.classList.contains('igx-grid--cosy')).toBe(true);
            expect(grid.defaultRowHeight).toBe(40);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
            grid.displayDensity = 'compact';
            fixture.detectChanges();
            tick(100);
            expect(grid.nativeElement.classList.contains('igx-grid--compact')).toBe(true);
            expect(grid.defaultRowHeight).toBe(32);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
        }));

        it('should render empty message', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css('.igx-grid__tbody'));

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(1000);

            // Check for empty filter grid message and body less than 100px
            const columns = fixture.componentInstance.grid.columns;
            grid.filter(columns[0].field, 546000, IgxNumberFilteringOperand.instance().condition('equals'));
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.innerText.substr(0,
                gridBody.nativeElement.innerText.length - 1)).toEqual(grid.emptyFilteredGridMessage);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeLessThan(100);

            // Clear filter and check if grid's body height is restored based on all loaded rows
            grid.clearFilter(columns[0].field);
            fixture.detectChanges();
            tick(100);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(1000);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.innerText.substr(0,
                gridBody.nativeElement.innerText.length - 1)).toEqual(grid.emptyGridMessage);
        }));
    });

    describe('IgxGrid - default rendering for rows and columns', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent,
                    IgxGridWrappedInContComponent,
                    IgxGridFormattingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should init columns with width >= 136px when 5 rows and 5 columns are rendered', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 5);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[2].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should init columns with width >= 136px when 30 rows and 10 columns are rendered', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(30, 10);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[6].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 1000 rows and 30 columns are rendered`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                fix.componentInstance.initColumnsRows(1000, 30);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;

                expect(grid.columns[0].width).not.toBeLessThan(136);
                expect(grid.columns[4].width).not.toBeLessThan(136);
                expect(grid.columns[14].width).not.toBeLessThan(136);
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            });

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 200 rows and 150 columns are rendered`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                fix.componentInstance.initColumnsRows(200, 150);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;

                expect(grid.columns[0].width).not.toBeLessThan(136);
                expect(grid.columns[4].width).not.toBeLessThan(136);
                expect(grid.columns[100].width).not.toBeLessThan(136);
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it('should account for columns with set width when determining default column width when grid has 100% width', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('100px');
            expect(grid.columns[4].width).toEqual('100px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should account for columns with set width when determining default column width when grid has px width', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '600px';
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('600px');
            expect(grid.columns[0].width).toEqual('100px');
            expect(grid.columns[4].width).toEqual('100px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                const grid = fix.componentInstance.grid;
                fix.componentInstance.initColumnsRows(30, 5);
                fix.componentInstance.changeInitColumns = true;
                fix.detectChanges();

                expect(grid.width).toEqual('100%');
                expect(grid.columns[0].width).toEqual('100px');
                expect(grid.columns[4].width).toEqual('100px');

                const actualGridWidth = grid.nativeElement.clientWidth;

                const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                    parseInt(grid.columns[0].width, 10) -
                    parseInt(grid.columns[4].width, 10)) / 3),
                    parseInt(MIN_COL_WIDTH, 10));
                expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

                expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
                expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
                expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

                grid.columns.forEach((column) => {
                    const width = parseInt(column.width, 10);
                    const minWidth = parseInt(grid.columnWidth, 10);
                    if (column.index !== 0 && column.index !== 4) {
                        expect(width).toBeGreaterThanOrEqual(minWidth);
                    }
                });

                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                const grid = fix.componentInstance.grid;
                fix.componentInstance.initColumnsRows(1000, 30);
                fix.componentInstance.changeInitColumns = true;
                fix.detectChanges();

                expect(grid.width).toEqual('100%');
                expect(grid.columns[0].width).toEqual('200px');
                expect(grid.columns[3].width).toEqual('200px');
                expect(grid.columns[5].width).toEqual('200px');
                expect(grid.columns[10].width).toEqual('200px');
                expect(grid.columns[25].width).toEqual('200px');

                const actualGridWidth = grid.nativeElement.clientWidth;

                const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
                expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);
                expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
                expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
                expect(parseInt(grid.columns[4].width, 10)).toEqual(expectedDefWidth);

                grid.columns.forEach((column) => {
                    const width = parseInt(column.width, 10);
                    const minWidth = parseInt(grid.columnWidth, 10);
                    if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                        column.index !== 10 && column.index !== 25) {
                        expect(width).toEqual(minWidth);
                    }
                });

                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                const grid = fix.componentInstance.grid;
                grid.width = '800px';
                fix.componentInstance.initColumnsRows(1000, 30);
                fix.componentInstance.changeInitColumns = true;
                fix.detectChanges();

                expect(grid.width).toEqual('800px');
                expect(grid.columns[0].width).toEqual('200px');
                expect(grid.columns[3].width).toEqual('200px');
                expect(grid.columns[5].width).toEqual('200px');
                expect(grid.columns[10].width).toEqual('200px');
                expect(grid.columns[25].width).toEqual('200px');

                const actualGridWidth = grid.nativeElement.clientWidth;
                const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
                expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

                grid.columns.forEach((column) => {
                    const width = parseInt(column.width, 10);
                    const minWidth = parseInt(grid.columnWidth, 10);
                    if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                        column.index !== 10 && column.index !== 25) {
                        expect(width).toEqual(minWidth);
                    }
                });
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are 10000 rows and 150 columns`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                const grid = fix.componentInstance.grid;
                fix.componentInstance.initColumnsRows(10000, 150);
                fix.componentInstance.changeInitColumns = true;
                fix.detectChanges();

                expect(grid.width).toEqual('100%');
                expect(grid.columns[0].width).toEqual('500px');
                expect(grid.columns[3].width).toEqual('500px');
                expect(grid.columns[5].width).toEqual('500px');
                expect(grid.columns[10].width).toEqual('500px');
                expect(grid.columns[50].width).toEqual('500px');

                grid.columns.forEach((column) => {
                    const width = parseInt(column.width, 10);
                    const minWidth = parseInt(grid.columnWidth, 10);
                    if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                        column.index !== 10 && column.index !== 50) {
                        expect(width).toEqual(minWidth);
                    }
                });

                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are 10000 rows and 150 columns`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                const grid = fix.componentInstance.grid;
                grid.width = '800px';
                fix.componentInstance.initColumnsRows(10000, 150);
                fix.componentInstance.changeInitColumns = true;
                fix.detectChanges();

                expect(grid.width).toEqual('800px');
                expect(grid.columns[0].width).toEqual('500px');
                expect(grid.columns[3].width).toEqual('500px');
                expect(grid.columns[5].width).toEqual('500px');
                expect(grid.columns[10].width).toEqual('500px');
                expect(grid.columns[50].width).toEqual('500px');

                grid.columns.forEach((column) => {
                    const width = parseInt(column.width, 10);
                    const minWidth = parseInt(grid.columnWidth, 10);
                    if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                        column.index !== 10 && column.index !== 50) {
                        expect(width).toEqual(minWidth);
                    }
                });

                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                expect(grid.rowList.length).toBeGreaterThan(0);
            });

        it('should render all records if height is explicitly set to null.', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(20, 5);
            grid.height = null;
            fix.detectChanges();

            const recsCount = grid.data.length;

            // tbody should have height equal to all items * item height
            expect(grid.tbody.nativeElement.clientHeight).toEqual(recsCount * 50);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should match width and height of parent container when width/height are set in %', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.outerWidth = 800;
            fix.componentInstance.outerHeight = 600;
            fix.componentInstance.grid.width = '50%';
            fix.componentInstance.grid.height = '50%';

            fix.detectChanges();

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should render 10 records if height is unset and parent container\'s height is unset', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it('should render 10 records if height is 100% and parent container\'s height is unset', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.grid.height = '700px';
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it(`should render all records exactly if height is 100% and parent container\'s height is unset and
            there are fewer than 10 records in the data view`, () => {
                const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
                fix.componentInstance.grid.height = '100%';
                fix.componentInstance.data = fix.componentInstance.data.slice(0, 5);
                fix.detectChanges();
                const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
                expect(defaultHeight).not.toBeNull();
                expect(parseInt(defaultHeight, 10)).toBeGreaterThan(200);
                expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeFalsy();
                expect(fix.componentInstance.grid.rowList.length).toEqual(5);
            });

        it(`should render 10 records if height is 100% and parent container\'s height is unset and
            display density is changed`, () => {
                const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
                fix.componentInstance.grid.height = '100%';
                fix.componentInstance.data = fix.componentInstance.data.slice(0, 11);
                fix.componentInstance.density = DisplayDensity.compact;
                fix.detectChanges();
                const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
                const defaultHeightNum = parseInt(defaultHeight, 10);
                expect(defaultHeight).not.toBeNull();
                expect(defaultHeightNum).toBeGreaterThan(300);
                expect(defaultHeightNum).toBeLessThan(330);
                expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
                expect(fix.componentInstance.grid.rowList.length).toEqual(11);
            });

        it('should render correct columns if after scrolling right container size changes so that all columns become visible.', (done) => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '500px';
            fix.componentInstance.initColumnsRows(5, 5);

            fix.detectChanges();
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            const scrollbar = grid.parentVirtDir.getHorizontalScroll();
            scrollbar.scrollLeft = 10000;
            grid.width = '1500px';

            setTimeout(() => {
                fix.detectChanges();
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
                const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
                expect(headers.length).toEqual(5);
                for (let i = 0; i < headers.length; i++) {
                    expect(headers[i].context.column.field).toEqual(grid.columns[i].field);
                }
                done();
            }, 100);
        });

        it('Should render date and number values based on default formatting', () => {
            const fixture = TestBed.createComponent(IgxGridFormattingComponent);
            fixture.detectChanges();
            const grid = fixture.componentInstance.grid;
            const rows = grid.rowList.toArray();
            // verify default number formatting
            let expectedValue = '2,760';
            expect(rows[0].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1,098';
            expect(rows[5].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7,898';
            expect(rows[7].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            // verify formatter function formatting
            expectedValue = '2.76e+3';
            expect(rows[0].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1.098e+3';
            expect(rows[5].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7.898e+3';
            expect(rows[7].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            // verify date formatting
            expectedValue = 'Mar 21, 2005';
            expect(rows[0].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Jan 15, 2008';
            expect(rows[1].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Nov 20, 2010';
            expect(rows[2].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            // verify summaries formatting
            let avgValue;
            let earliestValue;
            const summaries = fixture.debugElement.queryAll(By.css('.igx-grid-summary'));
            summaries.forEach((summary) => {
                const avgLabel = summary.query(By.css('[title=\'Avg\']'));
                const earliest = summary.query(By.css('[title=\'Earliest\']'));
                if (avgLabel) {
                    avgValue = avgLabel.nativeElement.nextSibling.innerText;
                    expect(avgValue).toBe('3,900.4');
                }
                if (earliest) {
                    earliestValue = earliest.nativeElement.nextSibling.innerText;
                    expect(earliestValue).toBe('May 17, 1990');
                }
            });
        });
    });

    describe('IgxGrid - keyboard navigation tests', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should allow pageup/pagedown navigation when the grid is focused', (done) => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            const pageDownKeyEvent = new KeyboardEvent('keydown', {
                code: 'PageDown',
                key: 'PageDown'
            });
            const pageUpKeyEvent = new KeyboardEvent('keydown', {
                code: 'PageUp',
                key: 'PageUp'
            });
            let currScrollTop;
            grid.width = '800px';
            grid.height = '500px';
            fix.componentInstance.initColumnsRows(25, 25);
            fix.detectChanges();
            grid.nativeElement.dispatchEvent(new Event('focus'));

            // testing the pagedown key
            grid.nativeElement.dispatchEvent(pageDownKeyEvent);
            grid.cdr.detectChanges();
            setTimeout(() => {
                currScrollTop = grid.verticalScrollContainer.getVerticalScroll().scrollTop;
                expect(currScrollTop).toEqual(grid.verticalScrollContainer.igxForContainerSize);

                // testing the pageup key
                grid.nativeElement.dispatchEvent(pageUpKeyEvent);
                grid.cdr.detectChanges();
                setTimeout(() => {
                    currScrollTop = grid.parentVirtDir.getHorizontalScroll().scrollTop;
                    expect(currScrollTop).toEqual(0);
                    done();
                }, 100);
            }, 0);
        });
    });

    describe('IgxGrid - API methods', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it(`When edit a cell onto filtered data through grid method, the row should
            disapear and the new value should not persist onto the next row`, () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                fix.componentInstance.initColumnsRows(5, 5);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const cols = fix.componentInstance.columns;
                const editValue = 0;

                grid.filter(cols[1].key, 2, IgxNumberFilteringOperand.instance().condition('greaterThan'));
                fix.detectChanges();
                grid.getCellByColumn(0, cols[1].key).update(editValue);
                fix.detectChanges();
                const gridRows = fix.debugElement.queryAll(By.css('igx-grid-row'));
                expect(gridRows.length).toEqual(1);
                const firstRowCells = gridRows[0].queryAll(By.css('igx-grid-cell'));
                const firstCellInputValue = firstRowCells[1].nativeElement.textContent.trim();
                expect(firstCellInputValue).toEqual('4');
            });
    });

    describe('Row Editing', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridRowEditingComponent,
                    IgxGridRowEditingWithoutEditableColumnsComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should be able to enter edit mode on dblclick, enter and f2', (async () => {
            const fix = TestBed.createComponent(IgxGridRowEditingComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const rv = fix.debugElement.query(By.css(`${CELL_CLASS}:last-child`));
            const row = grid.getRowByIndex(0);

            rv.nativeElement.dispatchEvent(new Event('focus'));
            fix.detectChanges();

            rv.triggerEventHandler('dblclick', {});
            expect(row.inEditMode).toBe(true);

            UIInteractions.triggerKeyDownEvtUponElem('escape', rv.nativeElement, true);
            await wait(DEBOUNCETIME);
            expect(row.inEditMode).toBe(false);

            UIInteractions.triggerKeyDownEvtUponElem('enter', rv.nativeElement, true);
            await wait(DEBOUNCETIME);
            expect(row.inEditMode).toBe(true);

            UIInteractions.triggerKeyDownEvtUponElem('escape', rv.nativeElement, true);
            await wait(DEBOUNCETIME);
            expect(row.inEditMode).toBe(false);

            // UIInteractions.triggerKeyDownEvtUponElem('f2', rv.nativeElement, true);
            // await wait(DEBOUNCETIME);
            // expect(row.inEditMode).toBe(true);

            // UIInteractions.triggerKeyDownEvtUponElem('escape', rv.nativeElement, true);
            // await wait(DEBOUNCETIME);
            // expect(row.inEditMode).toBe(false);
        }));

        it('should display the banner below the edited row if it is not the last one', (async () => {
            const fix = TestBed.createComponent(IgxGridRowEditingComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const rv = fix.debugElement.query(By.css(`${CELL_CLASS}:last-child`));
            const firstRow: HTMLElement = grid.getRowByIndex(1).nativeElement;

            rv.nativeElement.dispatchEvent(new Event('focus'));
            fix.detectChanges();

            rv.triggerEventHandler('dblclick', {});

            const banner: HTMLElement = document.getElementsByClassName('igx-overlay__content')[0] as HTMLElement;
            const bannerPosition = banner.offsetTop;
            const rowPosition = firstRow.offsetTop;
            const rowHeight = firstRow.clientHeight;

            // The banner appears below the row
            expect(bannerPosition).toBeGreaterThanOrEqual(rowPosition + rowHeight);

            // No much space between the row and the banner
            expect(bannerPosition - (rowPosition + rowHeight)).toBeLessThan(5);
        }));

        it('should display the banner above the edited row if it is the last one', (async () => {
            const fix = TestBed.createComponent(IgxGridRowEditingComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const cell = fix.debugElement.queryAll(By.css(CELL_CLASS))[28];
            const editRow: HTMLElement = grid.getRowByIndex(6).nativeElement;

            cell.nativeElement.dispatchEvent(new Event('focus'));
            fix.detectChanges();

            cell.triggerEventHandler('dblclick', {});

            const banner: HTMLElement = document.getElementsByClassName('igx-overlay__content')[0] as HTMLElement;
            const bannerPosition = banner.offsetTop;
            const bannerHeight = banner.clientHeight;
            const rowPosition = editRow.offsetTop;

            // The banner appears above the row
            expect(bannerPosition).toBeLessThanOrEqual(rowPosition - bannerHeight);

            // No much space between the row and the banner
            expect(rowPosition - (bannerPosition + bannerHeight)).toBeLessThan(5);
        }));
        // it('Should add correct class to the edited row', (async () => {
        //     const fix = TestBed.createComponent(IgxGridRowEditingComponent);
        //     fix.detectChanges();

        //     const grid = fix.componentInstance.gridRowEdit;
        //     const rv = fix.debugElement.queryAll(By.css(CELL_CSS_CLASS))[3];
        //     const firstRow = grid.getRowByIndex(0);
        //     const row: HTMLElement = grid.getRowByIndex(0).nativeElement;
        //     expect(row.classList).not.toContain('igx-grid__tr--edited');

        //     rv.nativeElement.dispatchEvent(new Event('focus'));
        //     fix.detectChanges();

        //     UIInteractions.triggerKeyDownEvtUponElem('enter', rv.nativeElement, true);
        //     await wait(DEBOUNCETIME);
        //     expect(firstRow.inEditMode).toBe(true);

        //     const input = fix.debugElement.queryAll(By.css('.igx-input-group'))[0];
        //     input.nativeElement.dispatchEvent(new Event('focus'));
        //     fix.detectChanges();
        it('Should add correct class to the edited row', (async () => {
            const fix = TestBed.createComponent(IgxGridRowEditingComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const cell = grid.getCellByColumn(0, 'ProductName');
            const row: HTMLElement = grid.getRowByIndex(0).nativeElement;
            expect(row.classList).not.toContain('igx-grid__tr--edited');

            cell.inEditMode = true;
            // expect(rowEditBanned) to be visible
            cell.update('IG');
            cell.inEditMode = false;

            await wait(DEBOUNCETIME);

            expect(row.classList).toContain('igx-grid__tr--edited');
        }));

        it(`Updated value should be preserved inside the cell when it enters edit mode again`, () => {
            // TO DO
        });

        describe('Row Editing - Navigation - Keyboard', () => {
            it(`Should be able to move between cells normally`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column pinning is enabled`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column hiding is enabled`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column pinning & hiding is enabled`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column grouping is enabled`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column paging is enabled`, () => {
                // TO DO
            });
            it(`Should skip non-editable columns when column when all column features are enabled`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Exit row editing', () => {
            it(`Should call correct methods on clicking DONE and CANCEL buttons in row edit overlay`, fakeAsync(() => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                spyOn(grid, 'closeRowTransaction');

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;
                fix.detectChanges();
                tick(DEBOUNCETIME);

                //  ged DONE button and click it
                const rowEditingBannerElement = fix.debugElement.query(By.css('.igx-banner'));
                const buttonElements = rowEditingBannerElement.queryAll(By.css('.igx-button--flat'));
                const doneButtonElement = buttonElements.find(el => el.nativeElement.innerText === grid.rowEditButtonDone);
                doneButtonElement.nativeElement.click();
                expect(grid.closeRowTransaction).toHaveBeenCalled();
                expect(grid.closeRowTransaction).toHaveBeenCalledWith(true);

                //  ged CANCLE button and click it
                const cancelButtonElement = buttonElements.find(el => el.nativeElement.innerText === grid.rowEditButtonCancel);
                cancelButtonElement.nativeElement.click();
                expect(grid.closeRowTransaction).toHaveBeenCalled();
                expect(grid.closeRowTransaction).toHaveBeenCalledWith(false);
            }));
            it(`Should exit row editing AND COMMIT on clicking the DONE button in row edit overlay`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                // 'click' on Done button
                grid.closeRowTransaction(true);
                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on add row`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                grid.addRow({ ProductID: 99, ProductName: 'ADDED', InStock: true, UnitsInStock: 20000, OrderDate: new Date('2018-03-01') });

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on delete row`, fakeAsync(() => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                grid.deleteRow(grid.getRowByIndex(2).rowID);
                fix.detectChanges();
                tick(DEBOUNCETIME);

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            }));
            it(`Should exit row editing AND COMMIT on filter`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                grid.filter('ProductName', 'a', IgxStringFilteringOperand.instance().condition('contains'), true);
                fix.detectChanges();

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on sort`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                grid.sort({ fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true });
                fix.detectChanges();

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on click on non-editable cell in same row`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                const nonEditableCell = grid.getCellByColumn(0, 'ProductID');
                nonEditableCell.nativeElement.click();

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on click on non-editable cell in other row`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                const nonEditableCell = grid.getCellByColumn(2, 'ProductID');
                nonEditableCell.nativeElement.click();

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND COMMIT on click on editable cell in other row`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // put cell in edit mode
                const cell = grid.getCellByColumn(0, 'ProductName');
                cell.inEditMode = true;

                const otherEditableCell = grid.getCellByColumn(2, 'ProductName');
                otherEditableCell.nativeElement.click();

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.submit_value).toHaveBeenCalledWith(grid.id);
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalledWith(grid.id, { rowID: 1, columnID: 3, rowIndex: 0 });
                expect(cell.inEditMode).toBeFalsy();
                expect(otherEditableCell.inEditMode).toBeTruthy();
            });
            it(`Should exit row editing AND COMMIT on ENTER KEYDOWN`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                const targetCell = grid.getCellByColumn(0, 'ProductName');
                targetCell.inEditMode = true;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                targetCell.dispatchEvent(new KeyboardEvent('keydown', {
                    code: 'enter',
                    key: 'enter'
                }));

                expect(gridAPI.submit_value).toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
                expect(targetCell.inEditMode).toBeFalsy();
            });
            it(`Should exit row editing AND DISCARD on clicking the CANCEL button in row edit overlay`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                const targetCell = grid.getCellByColumn(0, 'ProductName');
                targetCell.inEditMode = true;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                // get the cancel button and click it
                const rowEditingBannerElement = fix.debugElement.query(By.css('.igx-banner'));
                const buttonElements = rowEditingBannerElement.queryAll(By.css('.igx-button--flat'));
                const cancelButtonElement = buttonElements.find(el => el.nativeElement.innerText === grid.rowEditButtonCancel);
                cancelButtonElement.nativeElement.click();

                expect(gridAPI.submit_value).not.toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
            });
            it(`Should exit row editing AND DISCARD on ESC KEYDOWN`, () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const gridAPI: IgxGridAPIService = (<any>grid).gridAPI;

                const targetCell = grid.getCellByColumn(0, 'ProductName');
                targetCell.inEditMode = true;

                spyOn(gridAPI, 'submit_value').and.callThrough();
                spyOn(gridAPI, 'escape_editMode').and.callThrough();

                targetCell.dispatchEvent(new KeyboardEvent('keydown', {
                    code: 'escape',
                    key: 'escape'
                }));

                expect(gridAPI.submit_value).not.toHaveBeenCalled();
                expect(gridAPI.escape_editMode).toHaveBeenCalled();
            });
        });

        describe('Row Editing - Paging', () => {
            fit(`Should not apply edited classes to the same row on a different page`, (async () => {
                const fix = TestBed.createComponent(IgxGridRowEditingComponent);
                fix.detectChanges();

                const grid = fix.componentInstance.grid;
                const cell = grid.getCellByColumn(0, 'ProductName');
                const rowEl: HTMLElement = grid.getRowByIndex(0).nativeElement;

                expect(rowEl.classList).not.toContain('igx-grid__tr--edited');

                cell.inEditMode = true;
                cell.update('IG');
                cell.inEditMode = false;

                await wait(DEBOUNCETIME);

                expect(rowEl.classList).toContain('igx-grid__tr--edited');

                const gridElement: HTMLElement = fix.nativeElement.querySelector('.igx-grid');
                const pagingButtons = gridElement.querySelectorAll('.igx-paginator > button');

                // Next page button click
                pagingButtons[2].dispatchEvent(new Event('click'));
                fix.detectChanges();
                expect(grid.page).toEqual(1);
                expect(rowEl.classList).not.toContain('igx-grid__tr--edited');
            }));

            it(`Should preserve the changes after page navigation`, () => {
                // TO DO
            });

            it(`Should save changes when changing page while editing`, () => {
                // TO DO
            });

            it(`Should exit edit mode when changing the page size while editing`, () => {
                // TO DO
            });

            it(`Should exit edit mode when changing the page size resulting in the edited cell going to the next page`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Filtering', () => {
            it(`Should exit edit mode when filtering`, () => {
                // TO DO
                // Verify the data source is updated
            });

            it(`Should include the new value in the results when filtering`, () => {
                // TO DO
            });

            it(`Editing a filtered row`, () => {
                // TO DO
                // Filter by any value
                // Edit any of the filtered rows so that the row is removed from the filtered columns
                // Remove filtering
                // Verify the update is preserved
            });
        });

        describe('Row Editing - GroupBy', () => {
            it(`Should exit edit mode when Grouping`, () => {
                // TO DO
                // Verify the data source is updated
            });
        });

        describe('Row Editing - Summaries', () => {
            it(`Should update summaries when editing a row`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Sorting', () => {
            it(`Should exit edit mode when Sorting`, () => {
                // TO DO
                // Verify the data source is updated
            });

            it(`Should include the new value in the results when sorting`, () => {
                // TO DO
            });

            it(`Editing a sorted row`, () => {
                // TO DO
                // Sort any column
                // Edit any of the sorted rows so that the row position is changed
            });
        });

        describe('Row Editing - Summaries', () => {
            it(`Should update summaries when editing a row`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Column Moving', () => {
            it(`Should exit edit mode when moving a column`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Column Pinning', () => {
            it(`Should exit edit mode when pinning/unpinning a column`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Column Resizing', () => {
            it(`Should exit edit mode when resizing a column`, () => {
                // TO DO
            });
        });

        describe('Row Editing - Column Hiding', () => {
            it(`Should exit edit mode when hiding a column`, () => {
                // TO DO
            });

            it(`Should show the updated value when showing the column again`, () => {
                // TO DO
            });

            it(`Should be posible to update a cell that is hidden programatically`, () => {
                // TO DO
            });
        });

        it('Default column editable value is true, when row editing is enabled', () => {
            const fixture = TestBed.createComponent(IgxGridRowEditingWithoutEditableColumnsComponent);
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;

            const columns: IgxColumnComponent[] = grid.columnList.toArray();
            expect(columns[0].editable).toBeFalsy();
            expect(columns[1].editable).toBeFalsy();
            expect(columns[2].editable).toBeTruthy();
            expect(columns[3].editable).toBeTruthy();
            expect(columns[4].editable).toBeTruthy();
        });
    });

    /**
     * Finds visible cell's element by provided row and column indexes
     * @param debugElement Parent element where to look for the cell
     * @param rowIndex Visible index of the cell's row
     * @param columnIndex Visible index of cell's column
     */
    function getCellElementByRowAndColumnIndexes(
        debugElement: DebugElement,
        rowIndex: number,
        columnIndex: number,
        totalCols: number): DebugElement {
        const cells = debugElement.queryAll(By.css(CELL_CLASS));
        const cell = cells[rowIndex * totalCols + columnIndex];
        return cell;
    }
});

@Component({
    template: `<div style="width: 800px; height: 600px;">
        <igx-grid #grid [data]="data" [autoGenerate]="autoGenerate" (onColumnInit)="columnCreated($event)">
            <igx-column *ngFor="let column of columns;" [field]="column.field" [hasSummary]="column.hasSummary"
                [header]="column.field" [width]="column.width">
            </igx-column>
        </igx-grid>
    </div>`
})
export class IgxGridTestComponent {
    public data: any[] = [{ index: 1, value: 1 }];
    public columns = [
        { field: 'index', header: 'index', dataType: 'number', width: null, hasSummary: false },
        { field: 'value', header: 'value', dataType: 'number', width: null, hasSummary: false }
    ];
    @ViewChild('grid') public grid: IgxGridComponent;

    public autoGenerate = false;

    public columnEventCount = 0;

    public columnCreated(column: IgxColumnComponent) {
        this.columnEventCount++;
        column.filterable = true;
        column.sortable = true;
    }

    public isHorizontalScrollbarVisible() {
        const scrollbar = this.grid.parentVirtDir.getHorizontalScroll();
        if (scrollbar) {
            return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
        }

        return false;
    }

    public getVerticalScrollHeight() {
        const scrollbar = this.grid.verticalScrollContainer.getVerticalScroll();
        if (scrollbar) {
            return parseInt(scrollbar.style.height, 10);
        }

        return 0;
    }

    public isVerticalScrollbarVisible() {
        const scrollbar = this.grid.verticalScrollContainer.getVerticalScroll();
        if (scrollbar) {
            return scrollbar.offsetHeight < scrollbar.children[0].offsetHeight;
        }
        return false;
    }

    public generateData(rows) {
        const d = [];
        for (let r = 0; r < rows; r++) {
            const record = {};
            for (let c = 0; c < this.columns.length; c++) {
                record[this.columns[c].field] = c * r;
            }
            d.push(record);
        }
        this.data = d;
    }

    public clearData() {
        this.data = [];
    }
}

@Component({
    template: `<igx-grid #grid [data]="data" (onColumnInit)="initColumns($event)">
        <igx-column *ngFor="let col of columns" [field]="col.key" [header]="col.key" [dataType]="col.dataType">
        </igx-column>
    </igx-grid>`
})
export class IgxGridDefaultRenderingComponent {
    public columns = [];
    public data = [];

    public changeInitColumns = false;

    @ViewChild('grid', { read: IgxGridComponent })
    public grid: IgxGridComponent;

    public initColumnsRows(rowsNumber: number, columnsNumber: number): void {
        this.columns = [];
        this.data = [];
        let i, j: number;
        for (i = 0; i < columnsNumber; i++) {
            this.columns.push({
                key: 'col' + i,
                dataType: 'number'
            });
        }
        for (i = 0; i < rowsNumber; i++) {
            const record = {};
            for (j = 0; j < columnsNumber; j++) {
                record[this.columns[j].key] = j * i;
            }
            this.data.push(record);
        }
    }

    public isHorizonatScrollbarVisible() {
        const scrollbar = this.grid.parentVirtDir.getHorizontalScroll();
        return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
    }

    public initColumns(column) {
        if (this.changeInitColumns) {
            switch (this.grid.columnList.length) {
                case 5:
                    if (column.index === 0 || column.index === 4) {
                        column.width = '100px';
                    }
                    break;
                case 30:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 25) {
                        column.width = '200px';
                    }
                    break;
                case 150:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 50) {
                        column.width = '500px';
                    }
                    break;
            }
        }
    }
}

@Component({
    template:
        `<div [style.width.px]="outerWidth" [style.height.px]="outerHeight">
            <igx-grid #grid [data]="data" [displayDensity]="density" [autoGenerate]="true"
                [paging]="paging" [perPage]="pageSize">
            </igx-grid>
        </div>`
})
export class IgxGridWrappedInContComponent extends IgxGridTestComponent {
    public data = [
        { 'ID': 'ALFKI', 'CompanyName': 'Alfreds Futterkiste' },
        { 'ID': 'ANATR', 'CompanyName': 'Ana Trujillo Emparedados y helados' },
        { 'ID': 'ANTON', 'CompanyName': 'Antonio Moreno Taquera' },
        { 'ID': 'AROUT', 'CompanyName': 'Around the Horn' },
        { 'ID': 'BERGS', 'CompanyName': 'Berglunds snabbkp' },
        { 'ID': 'BLAUS', 'CompanyName': 'Blauer See Delikatessen' },
        { 'ID': 'BLONP', 'CompanyName': 'Blondesddsl pre et fils' },
        { 'ID': 'BOLID', 'CompanyName': 'Blido Comidas preparadas' },
        { 'ID': 'BONAP', 'CompanyName': 'Bon app\'' },
        { 'ID': 'BOTTM', 'CompanyName': 'Bottom-Dollar Markets' },
        { 'ID': 'BSBEV', 'CompanyName': 'B\'s Beverages' },
        { 'ID': 'CACTU', 'CompanyName': 'Cactus Comidas para llevar' },
        { 'ID': 'CENTC', 'CompanyName': 'Centro comercial Moctezuma' },
        { 'ID': 'CHOPS', 'CompanyName': 'Chop-suey Chinese' },
        { 'ID': 'COMMI', 'CompanyName': 'Comrcio Mineiro' },
        { 'ID': 'CONSH', 'CompanyName': 'Consolidated Holdings' },
        { 'ID': 'DRACD', 'CompanyName': 'Drachenblut Delikatessen' },
        { 'ID': 'DUMON', 'CompanyName': 'Du monde entier' },
        { 'ID': 'EASTC', 'CompanyName': 'Eastern Connection' },
        { 'ID': 'ERNSH', 'CompanyName': 'Ernst Handel' },
        { 'ID': 'FAMIA', 'CompanyName': 'Familia Arquibaldo' },
        { 'ID': 'FISSA', 'CompanyName': 'FISSA Fabrica Inter' },
        { 'ID': 'FOLIG', 'CompanyName': 'Folies gourmandes' },
        { 'ID': 'FOLKO', 'CompanyName': 'Folk och f HB' },
        { 'ID': 'FRANK', 'CompanyName': 'Frankenversand' },
        { 'ID': 'FRANR', 'CompanyName': 'France restauration' },
        { 'ID': 'FRANS', 'CompanyName': 'Franchi S.p.A.' }
    ];

    public height = null;
    public paging = false;
    public pageSize = 5;
    public density = DisplayDensity.comfortable;
    public outerWidth = 800;
    public outerHeight: number;
}

@Component({
    template: `
        <igx-grid [data]="data" (onColumnInit)="columnCreated($event)">
            <igx-column field="ID"></igx-column>
            <igx-column field="Name"></igx-column>
        </igx-grid>
    `
})
export class IgxGridMarkupDeclarationComponent extends IgxGridTestComponent {
    public data = [
        { ID: 1, Name: 'Johny' },
        { ID: 2, Name: 'Sally' },
        { ID: 3, Name: 'Tim' }
    ];
    @ViewChild(IgxGridComponent, { read: IgxGridComponent })
    public instance: IgxGridComponent;
}

@Injectable()
export class LocalService {
    public records: Observable<any[]>;
    private _records: BehaviorSubject<any[]>;
    private dataStore: any[];

    constructor() {
        this.dataStore = [];
        this._records = new BehaviorSubject([]);
        this.records = this._records.asObservable();
    }

    public getData(data?: IForOfState, cb?: (any) => void): any {
        const size = data.chunkSize === 0 ? 10 : data.chunkSize;
        this.dataStore = this.generateData(data.startIndex, data.startIndex + size);
        this._records.next(this.dataStore);
        const count = 1000;
        if (cb) {
            cb(count);
        }
    }

    public generateData(start, end) {
        const dummyData = [];
        for (let i = start; i < end; i++) {
            dummyData.push({ Col1: 10 * i });
        }
        return dummyData;
    }
}

@Component({
    template: `
        <igx-grid [data]="data | async" (onDataPreLoad)="dataLoading($event)" [height]="'600px'">
            <igx-column [sortable]="true" [filterable]="true" [field]="'Col1'" [header]="'Col1'">
            </igx-column>
        </igx-grid>
    `,
    providers: [LocalService]
})
export class IgxGridRemoteVirtualizationComponent implements OnInit, AfterViewInit {
    public data;
    @ViewChild(IgxGridComponent, { read: IgxGridComponent })
    public instance: IgxGridComponent;
    constructor(private localService: LocalService, public cdr: ChangeDetectorRef) { }
    public ngOnInit(): void {
        this.data = this.localService.records;
    }

    public ngAfterViewInit() {
        this.localService.getData(this.instance.virtualizationState, (count) => {
            this.instance.totalItemCount = count;
            this.cdr.detectChanges();
        });
    }

    dataLoading(evt) {
        this.localService.getData(evt, () => {
            this.cdr.detectChanges();
        });
    }
}

@Component({
    template: GridTemplateStrings.declareGrid(
        '', '',
        `<igx-column field="ProductID" header="Product ID">
        </igx-column>
        <igx-column field="ProductName">
        </igx-column>
        <igx-column field="InStock" [dataType]="'boolean'">
        </igx-column>
        <igx-column field="UnitsInStock" [dataType]="'number'" [hasSummary]="true">
        </igx-column>
        <igx-column field="OrderDate" width="200px" [dataType]="'date'" [hasSummary]="true">
        </igx-column><igx-column field="UnitsInStock" [formatter]="formatNum" [dataType]="'number'" [hasSummary]="true">
        </igx-column>`)
})
export class IgxGridFormattingComponent extends BasicGridComponent {
    public data = SampleTestData.foodProductData();
    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
    public width = '600px';
    public height = '400px';
    public value: any;
    public formatNum() {
        return this.value.toExponential().toString();
    }
}

@Component({
    template: `
    <igx-grid #grid [data]="data" [primaryKey]="'ProductID'" width="700px" height="400px" [rowEditable]="true"
    [paging]="true" [perPage]="7">
        <igx-column>
            <ng-template igxCell let-cell="cell" let-val>
                <button (click)="deleteRow($event, cell.cellID.rowID)">Delete</button>
            </ng-template>
        </igx-column>
        <igx-column field="ProductID" header="Product ID"></igx-column>
        <igx-column field="ReorderLevel" header="Reorder Lever" [dataType]="'number'" editable="true" width="100px"></igx-column>
        <igx-column field="ProductName" header="Product Name" [dataType]="'string'" editable="true" width="150px"></igx-column>
        <igx-column field="OrderDate" header="Order Date" [dataType]="'date'" editable="true" width="150px"></igx-column>
    </igx-grid>`
})
export class IgxGridRowEditingComponent {
    public data = SampleTestData.foodProductData();

    public changeInitColumns = false;

    @ViewChild('grid', { read: IgxGridComponent }) public grid: IgxGridComponent;

    public deleteRow(event, rowID) {
        event.stopPropagation();
        this.data.splice(rowID - 1, 1);
        this.refreshAll();
    }

    refreshAll(): void {
        this.refresh(this.grid);
    }

    private refresh(grid: IgxGridComponent): void {
        (<any>grid)._pipeTrigger++;
        (<any>grid).cdr.markForCheck();
    }
}

@Component({
    template: `
    <igx-grid #grid [data]="data" [primaryKey]="'ProductID'" width="700px" height="400px" [rowEditable]="true">
        <igx-column [editable]="false">
            <ng-template igxCell let-cell="cell" let-val>
                <button (click)="deleteRow($event, cell.cellID.rowID)">Delete</button>
            </ng-template>
        </igx-column>
        <igx-column field="ProductID" header="Product ID" [editable]="false"></igx-column>
        <igx-column field="ReorderLevel" header="Reorder Lever" [dataType]="'number'" [editable]="true" width="100px"></igx-column>
        <igx-column field="ProductName" header="Product Name" [dataType]="'string'" width="150px"></igx-column>
        <igx-column field="OrderDate" header="Order Date" [dataType]="'date'" width="150px"></igx-column>
    </igx-grid>`
})
export class IgxGridRowEditingWithoutEditableColumnsComponent {
    public data = SampleTestData.foodProductData();
    @ViewChild('grid', { read: IgxGridComponent }) public grid: IgxGridComponent;
}

