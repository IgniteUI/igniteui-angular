import { cloneArray, columnFieldPath, parseDate, resolveNestedPath } from '../core/utils';
import { IGroupByExpandState } from './groupby-expand-state.interface';
import { IGroupByRecord } from './groupby-record.interface';
import { IGroupingState } from './groupby-state.interface';
import { IGroupingExpression } from './grouping-expression.interface';
import { IGroupByResult } from './grouping-result.interface';
import { getHierarchy, isHierarchyMatch } from './operations';
import { DefaultSortingStrategy, ISortingExpression, SortingDirection } from './sorting-strategy';
import type { GridType } from './grid-types-stub';

const DATE_TYPE = 'date';
const TIME_TYPE = 'time';
const DATE_TIME_TYPE = 'dateTime';
const STRING_TYPE = 'string';

/**
 * Represents a sorting strategy for the grid data
 * Contains a single method sort that sorts the provided data based on the given sorting expressions
 */
export interface IGridSortingStrategy {
    /* blazorCSSuppress */
    /**
    * `data`: The array of data to be sorted. Could be of any type.
    * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
    * `grid`: (Optional) The instance of the grid where the sorting is applied.
    * Returns a new array with the data sorted according to the sorting expressions.
    */
    sort(data: any[], expressions: ISortingExpression[], grid?: GridType): any[];
}

/**
 * Represents a grouping strategy for the grid data, extending the Sorting Strategy interface (contains a sorting method).
 */
export interface IGridGroupingStrategy extends IGridSortingStrategy {
    /* blazorCSSuppress */
    /**
     * The method groups the provided data based on the given grouping state and returns the result.
     * `data`: The array of data to be grouped. Could be of any type.
     * `state`: The grouping state that defines the grouping settings and expressions.
     * `grid`: (Optional) The instance of the grid where the grouping is applied.
     * `groupsRecords`: (Optional) An array that holds the records for each group.
     * `fullResult`: (Optional) The complete result of grouping including groups and summary data.
     * Returns an object containing the result of the grouping operation.
     */
    groupBy(data: any[], state: IGroupingState, grid?: any, groupsRecords?: any[], fullResult?: IGroupByResult): IGroupByResult;
}

/**
 * Represents internal sorting expression that extends the public one.
 * Contains boolean properties that represent the type of the column that is being sorted.
 * @internal
 */
interface IGridInternalSortingExpression extends ISortingExpression {
    isDate: boolean;
    isTime: boolean;
    isString: boolean;
}

/**
 * Stack item represents a frame.
 * Each frame needs:
 * - data: The subset of records to process at this level.
 * - level: The current grouping level.
 * - parentGroup: The parent IGroupByRecord for groups created in this frame.
 * - currentIndex: The index within 'data' to start processing.
 * - isExpandingChildren: Flag to indicate if children generated by this group should be added to `result` and `metadata`.
 * @internal
 */
interface StackFrame {
    data: any[];
    level: number;
    parentGroup: IGroupByRecord | null;
    currentIndex: number;
    isExpandingChildren: boolean;
}

/**
 * Represents a class implementing the IGridSortingStrategy interface.
 * It provides sorting functionality for grid data based on sorting expressions.
 */
export class IgxSorting implements IGridSortingStrategy {
    /* blazorSuppress */
    /**
   * Sorts the provided data based on the given sorting expressions.
   * `data`: The array of data to be sorted.
   * `expressions`: An array of sorting expressions that define the sorting rules. The expression contains information like file name, whether the letter case should be taken into account, etc.
   * `grid`: (Optional) The instance of the grid where the sorting is applied.
   * Returns a new array with the data sorted according to the sorting expressions.
   */
    public sort(data: any[], expressions: ISortingExpression[], grid?: GridType): any[] {
        return this.sortData(data, expressions, grid);
    }

    /**
     * Retrieves the value of the specified field from the given object, considering date and time data types.
     * `key`: The key of the field to retrieve.
     * `isDate`: (Optional) Indicates if the field is of type Date.
     * `isTime`: (Optional) Indicates if the field is of type Time.
     * Returns the value of the specified field in the data object.
     * @internal
     */
    protected getFieldValue<T>(obj: T, key: string, isDate = false, isTime = false) {
        let resolvedValue = resolveNestedPath(obj, columnFieldPath(key));
        if (isDate || isTime) {
            const date = parseDate(resolvedValue);
            if (date && isDate && isTime) {
                resolvedValue = date;
            } else if (date && isDate && !isTime) {
                resolvedValue = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
            } else if (date && isTime && !isDate) {
                resolvedValue = new Date(new Date().setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
            }
        }
        return resolvedValue;
    }

    /**
   * Sorts the provided data array based on the given sorting expressions.
   * The method can be used when multiple sorting is performed, going through each one
   * Returns a new array with the data sorted according to the sorting expressions.
   * @internal
   */
    private sortData<T>(
        data: T[],
        expressions: ISortingExpression[],
        grid: GridType
    ): T[] {
        const sortingExpressions = this.prepareExpressions(expressions, grid);

        if (data.length <= 1) {
            return data;
        }

        for (let i = sortingExpressions.length - 1; i >= 0; i--) {
            data = sortingExpressions[i].strategy.sort(data, sortingExpressions[i].fieldName, sortingExpressions[i].dir, sortingExpressions[i].ignoreCase, this.getFieldValue, sortingExpressions[i].isDate, sortingExpressions[i].isTime, grid)
        }

        return data;
    }

    private prepareExpressions(expressions: ISortingExpression[], grid: GridType): IGridInternalSortingExpression[] {
        const multipleSortingExpressions: IGridInternalSortingExpression[] = [];
        for (const expr of expressions) {
            if (expr.dir === SortingDirection.None) {
                continue;
            }
            if (!expr.strategy) {
                expr.strategy = DefaultSortingStrategy.instance();
            }
            const column = grid?.getColumnByName(expr.fieldName);
            const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isString = column?.dataType === STRING_TYPE;
            multipleSortingExpressions.push({ ...expr, isDate, isTime, isString })
        }
        return multipleSortingExpressions;
    }
}

/**
 * Represents a class implementing the IGridGroupingStrategy interface and extending the IgxSorting class.
 * It provides a method to group data based on the given grouping state.
 */
export class IgxGrouping extends IgxSorting implements IGridGroupingStrategy {
    /* blazorSuppress */
    /**
     * Groups the provided data based on the given grouping state.
     * Returns an object containing the result of the grouping operation.
     */
    public groupBy(data: any[], state: IGroupingState, grid?: any,
        groupsRecords?: any[], fullResult: IGroupByResult = { data: [], metadata: [] }): IGroupByResult {
        const grouping = this.groupData(data, state, grid, groupsRecords, fullResult);
        grid?.groupingPerformedSubject.next();
        return {
            data: grouping.data,
            metadata: grouping.metadata
        };
    }

    /**
     * Groups the provided data based on the given grouping state.
     * Changes groupsRecords and fullResult collections by reference.
     * Returns an array containing the visible grouped result.
     * @internal
     */
    protected groupData(
        data: any[],
        state: IGroupingState,
        grid: GridType = null,
        groupsRecords: any[] = [],
        fullResult: IGroupByResult
    ): IGroupByResult {

        const expressions = state.expressions;
        const expansion = state.expansion;

        // This holds the final visible data (the rows that are expanded).
        const result: any[] = [];

        // This holds the group rows for each record in the result array. Used in grid for information when scrolling.
        const metadata: IGroupByRecord[] = [];

        // Initialize the stack with the root level processing.
        const initialFrame: StackFrame = {
            data: data,
            level: 0,
            parentGroup: null,
            currentIndex: 0,
            isExpandingChildren: true
        };
        const stack: StackFrame[] = [initialFrame];

        while (stack.length > 0) {
            const currentFrame = stack[stack.length - 1]; // Peek at the top of the stack

            const { data: currentData, level, parentGroup, currentIndex, isExpandingChildren } = currentFrame;

            // If we've processed all data in this frame, pop it.
            if (currentIndex >= currentData.length) {
                stack.pop();
                continue;
            }

            // Process the next group at the current level
            const column = grid ? grid.getColumnByName(expressions[level].fieldName) : null;
            const isDate = column?.dataType === DATE_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isTime = column?.dataType === TIME_TYPE || column?.dataType === DATE_TIME_TYPE;
            const isString = column?.dataType === STRING_TYPE;

            // Next block of grouped records for the expression of the current level
            const group = this.groupedRecordsByExpression(
                currentData,
                currentIndex,
                expressions[level],
                isDate,
                isTime,
                isString,
                column?.groupingComparer
            );

            // Create the group row
            const groupRow: IGroupByRecord = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: this.getFieldValue(group[0], expressions[level].fieldName, isDate, isTime),
                groupParent: parentGroup,
                groups: [],
                height: grid ? grid.renderedRowHeight : null,
                column
            };

            // Link to parent's groups list
            if (parentGroup) {
                parentGroup.groups.push(groupRow);
            } else {
                groupsRecords.push(groupRow)
            }

            // Determine expansion state for this groupRow
            const hierarchy = getHierarchy(groupRow);
            const expandState: IGroupByExpandState = expansion.find((s) =>
                isHierarchyMatch(
                    s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }],
                    hierarchy,
                    expressions
                )
            );
            const expandedForThisGroup = expandState ? expandState.expanded : state.defaultExpanded;

            // Add the group row to the full result set
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);

            // Add the group row to the visible results (if its parent was expanded or it's a root group)
            if (isExpandingChildren) {
                result.push(groupRow);
                metadata.push(null);
            }

            // Advance the current frame's index for the next iteration of its loop
            currentFrame.currentIndex += group.length;

            if (level < expressions.length - 1) {
                // If there are more levels to group, push a new frame onto the stack
                const nextFrame: StackFrame = {
                    data: group, // The records of the current group become the data for the next level
                    level: level + 1,
                    parentGroup: groupRow, // The current group row is the parent for the next level
                    currentIndex: 0,
                    isExpandingChildren: isExpandingChildren && expandedForThisGroup // Children are expanded only if this group is expanded AND parent is expanded
                };
                stack.push(nextFrame);
            } else {
                // This is the leaf level, add individual items to fullResult and conditionally to result/metadata
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow); // The metadata for an item is its immediate parent group row.
                    fullResult.data.push(groupItem);
                    if (isExpandingChildren && expandedForThisGroup) {
                        // Add to result and metadata only if expanded
                        metadata.push(groupRow);
                        result.push(groupItem);
                    }
                }
            }
        }

        return { data: result, metadata };
    }

    /**
     * Groups the records in the provided data array based on the given grouping expression.
     * `groupingComparer`: (Optional) A custom grouping comparator to determine the members of the group.
     * Returns an array containing the records that belong to the group.
     * @internal
     */
    private groupedRecordsByExpression<T>(
        data: T[],
        index: number,
        expression: IGroupingExpression,
        isDate = false,
        isTime = false,
        isString: boolean,
        groupingComparer?: (a: any, b: any, currRec: any, groupRec: any) => number
    ): T[] {
        const res: T[] = [];
        const key = expression.fieldName;
        const len = data.length;
        const groupRecord = data[index];
        let groupValue = this.getFieldValue(groupRecord, key, isDate, isTime);
        if (expression.ignoreCase && isString && groupValue) {
            // when column's dataType is string but the value is number
            groupValue = groupValue.toString().toLowerCase();
        }
        res.push(groupRecord);
        const comparer = expression.groupingComparer || groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (let i = index + 1; i < len; i++) {
            const currRec = data[i];
            let fieldValue = this.getFieldValue(currRec, key, isDate, isTime);
            if (expression.ignoreCase && isString && fieldValue) {
                // when column's dataType is string but the value is number
                fieldValue = fieldValue.toString().toLowerCase();
            }
            if (comparer(fieldValue, groupValue, currRec, groupRecord) === 0) {
                res.push(currRec);
            } else {
                break;
            }
        }
        return res;
    }
}

/* csSuppress */
/**
 * Represents a class implementing the IGridSortingStrategy interface with a no-operation sorting strategy.
 * It performs no sorting and returns the data as it is.
 */
export class NoopSortingStrategy implements IGridSortingStrategy {
    private static _instance: NoopSortingStrategy = null;

    private constructor() { }

    public static instance(): NoopSortingStrategy {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }

    /* csSuppress */
    public sort(data: any[]): any[] {
        return data;
    }
}

/**
 * Represents a class extending the IgxSorting class
 * Provides custom data record sorting.
 */
export class IgxDataRecordSorting extends IgxSorting {
    /**
    * Overrides the base method to retrieve the field value from the data object instead of the record object.
    * Returns the value of the specified field in the data object.
    */
    protected override getFieldValue(obj: any, key: string, isDate = false, isTime = false): any {
        return super.getFieldValue(obj.data, key, isDate, isTime);
    }
}
