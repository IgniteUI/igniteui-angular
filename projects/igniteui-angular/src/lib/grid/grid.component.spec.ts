import { AfterViewInit, ChangeDetectorRef, Component, Injectable, OnInit, ViewChild } from '@angular/core';
import { async, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { BehaviorSubject, Observable } from 'rxjs';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { IgxGridAPIService } from './api.service';
import { IgxGridComponent } from './grid.component';
import { IgxColumnComponent } from './column.component';
import { IForOfState} from '../directives/for-of/for_of.directive';
import { IgxGridModule } from './index';
import { IgxNumberFilteringOperand } from '../../public_api';
import { DisplayDensity } from '../core/utils';
import { DataType } from '../data-operations/data-util';
import { GridTemplateStrings } from '../test-utils/template-strings.spec';
import { SampleTestData } from '../test-utils/sample-test-data.spec';
import { BasicGridComponent } from '../test-utils/grid-base-components.spec';

describe('IgxGrid Component Tests', () => {
    const MIN_COL_WIDTH = '136px';
    const COLUMN_HEADER_CLASS = '.igx-grid__th';

    describe('IgxGrid - input properties', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridTestComponent,
                    IgxGridMarkupDeclarationComponent,
                    IgxGridRemoteVirtualizationComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should initialize a grid with columns from markup', () => {
            const fix = TestBed.createComponent(IgxGridMarkupDeclarationComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.instance;
            const domGrid = fix.debugElement.query(By.css('igx-grid')).nativeElement;

            expect(grid).toBeDefined('Grid initializing through markup failed');
            expect(grid.columnList.length).toEqual(2, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(3, 'Invalid number of rows initialized');

            expect(grid.id).toContain('igx-grid-');
            expect(domGrid.id).toContain('igx-grid-');

            grid.id = 'customGridId';
            fix.detectChanges();

            expect(grid.id).toBe('customGridId');
            expect(domGrid.id).toBe('customGridId');
            expect(fix.componentInstance.columnEventCount).toEqual(2);
        });

        it('should initialize a grid with autogenerated columns', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.data = [
                { Number: 1, String: '1', Boolean: true, Date: new Date(Date.now()) }
            ];
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid).toBeDefined('Grid initializing through autoGenerate failed');
            expect(grid.columnList.length).toEqual(4, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(1, 'Invalid number of rows initialized');
            expect(grid.columnList.first.dataType).toEqual(DataType.Number, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 1).dataType)
                    .toEqual(DataType.String, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 2).dataType)
                    .toEqual(DataType.Boolean, 'Invalid dataType set on column');
            expect(grid.columnList.last.dataType).toEqual(DataType.Date, 'Invalid dataType set on column');
            expect(fix.componentInstance.columnEventCount).toEqual(4);
        });

        it('should initialize a grid and change column properties during initialization', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            grid.columnList.forEach((column) => {
                expect(column.filterable).toEqual(true);
                expect(column.sortable).toEqual(true);
            });
        });

        it('should initialize grid with remove virtualization', (done) => {
            const fix = TestBed.createComponent(IgxGridRemoteVirtualizationComponent);
            fix.detectChanges();
            let rows = fix.componentInstance.instance.rowList.toArray();
            expect(rows.length).toEqual(10);

            const verticalScroll = fix.componentInstance.instance.verticalScrollContainer;
            const elem =  verticalScroll['vh'].instance.elementRef.nativeElement;

            // scroll down
            expect(() => {
                elem.scrollTop = 1000;
                fix.detectChanges();
                fix.componentRef.hostView.detectChanges();
            }).not.toThrow();

            setTimeout(() => {
                fix.detectChanges();
                fix.componentInstance.cdr.detectChanges();
                rows = fix.componentInstance.instance.rowList.toArray();
                const data = fix.componentInstance.data.source.getValue();
                for (let i = fix.componentInstance.instance.virtualizationState.startIndex; i < rows.length; i++) {
                    expect(rows[i].rowData['Col1'])
                        .toBe(data[i]['Col1']);
                }
                done();
            }, 500);
        });

        it('height/width should be calculated depending on number of records', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const gridBody = fix.debugElement.query(By.css('.igx-grid__tbody'));
            const gridHeader = fix.debugElement.query(By.css('.igx-grid__thead'));
            const gridFooter = fix.debugElement.query(By.css('.igx-grid__tfoot'));
            const gridScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            let gridBodyHeight;
            let verticalScrollHeight;

            fix.detectChanges();

            expect(grid.rowList.length).toEqual(1);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('50px');

            for (let i = 2; i <= 30; i++) {
                grid.addRow({ index: i, value: i });
            }

            fix.detectChanges();

            expect(grid.rowList.length).toEqual(30);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('1500px');
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(false);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);
            grid.height = '200px';
            fix.detectChanges();

            tick(200);
            fix.detectChanges();
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);
            verticalScrollHeight = fix.componentInstance.getVerticalScrollHeight();
            grid.width = '200px';

            tick(200);
            fix.detectChanges();
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.getVerticalScrollHeight()).toBeLessThan(verticalScrollHeight);
            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridScroll.nativeElement).height, 10);

            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('200px');
            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('200px');
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);
            grid.height = '50%';
            fix.detectChanges();
            tick(200);
            fix.detectChanges();

            grid.width = '50%';
            fix.detectChanges();
            tick(200);
            fix.detectChanges();

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');

            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10);

            // The scrollbar is no longer visible
            //    - parseInt(window.getComputedStyle(gridScroll.nativeElement).height, 10);
            // console.log(gridBodyHeight);
            // console.log(window.getComputedStyle(gridBody.nativeElement).height);
            // console.log(gridBodyHeight === parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10));
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);
        }));

        it('should not have column misalignment when no vertical scrollbar is shown', () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const gridBody = fix.debugElement.query(By.css('.igx-grid__tbody'));
            const gridHeader = fix.debugElement.query(By.css('.igx-grid__thead'));

            expect(window.getComputedStyle(gridBody.children[0].nativeElement).width).toEqual(
                window.getComputedStyle(gridHeader.children[0].nativeElement).width
            );
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should change displayDensity runtime correctly', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.columns[1].hasSummary = true;
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;
            const headerHight = fixture.debugElement.query(By.css('.igx-grid__thead')).query(By.css('.igx-grid__tr')).nativeElement;
            const rowHeight = fixture.debugElement.query(By.css('.igx-grid__tbody')).query(By.css('.igx-grid__tr')).nativeElement;
            const summaryItemHeigh = fixture.debugElement.query(By.css('.igx-grid__tfoot'))
            .query(By.css('.igx-grid-summary__item')).nativeElement;

            expect(grid.defaultRowHeight).toBe(50);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
            grid.displayDensity = 'cosy';
            fixture.detectChanges();
            tick(100);
            expect(grid.nativeElement.classList.contains('igx-grid--cosy')).toBe(true);
            expect(grid.defaultRowHeight).toBe(40);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
            grid.displayDensity = 'compact';
            fixture.detectChanges();
            tick(100);
            expect(grid.nativeElement.classList.contains('igx-grid--compact')).toBe(true);
            expect(grid.defaultRowHeight).toBe(32);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultRowHeight);
        }));

        it('should render empty message', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css('.igx-grid__tbody'));

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(1000);

            // Check for empty filter grid message and body less than 100px
            const columns = fixture.componentInstance.grid.columns;
            grid.filter(columns[0].field, 546000, IgxNumberFilteringOperand.instance().condition('equals'));
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.innerText.substr(0,
                gridBody.nativeElement.innerText.length - 1)).toEqual(grid.emptyFilteredGridMessage);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeLessThan(100);

            // Clear filter and check if grid's body height is restored based on all loaded rows
            grid.clearFilter(columns[0].field);
            fixture.detectChanges();
            tick(100);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(1000);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.innerText.substr(0,
                gridBody.nativeElement.innerText.length - 1)).toEqual(grid.emptyGridMessage);
        }));
    });

    describe('IgxGrid - default rendering for rows and columns', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent,
                    IgxGridWrappedInContComponent,
                    IgxGridFormattingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should init columns with width >= 136px when 5 rows and 5 columns are rendered', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 5);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[2].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should init columns with width >= 136px when 30 rows and 10 columns are rendered', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(30, 10);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[6].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 1000 rows and 30 columns are rendered`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[14].width).not.toBeLessThan(136);
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
        });

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 200 rows and 150 columns are rendered`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(200, 150);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[100].width).not.toBeLessThan(136);
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        xit('should account for columns with set width when determining default column width when grid has 100% width', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[4].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should account for columns with set width when determining default column width when grid has px width', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '800px';
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('800px');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[4].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        xit(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(30, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[4].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;

            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[3].width).toEqual('200px');
            expect(grid.columns[5].width).toEqual('200px');
            expect(grid.columns[10].width).toEqual('200px');
            expect(grid.columns[25].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;

            const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[4].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 25) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '800px';
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('800px');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[3].width).toEqual('200px');
            expect(grid.columns[5].width).toEqual('200px');
            expect(grid.columns[10].width).toEqual('200px');
            expect(grid.columns[25].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 25) {
                    expect(width).toEqual(minWidth);
                }
            });
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are 10000 rows and 150 columns`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(10000, 150);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('500px');
            expect(grid.columns[3].width).toEqual('500px');
            expect(grid.columns[5].width).toEqual('500px');
            expect(grid.columns[10].width).toEqual('500px');
            expect(grid.columns[50].width).toEqual('500px');

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 50) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are 10000 rows and 150 columns`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '800px';
            fix.componentInstance.initColumnsRows(10000, 150);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();

            expect(grid.width).toEqual('800px');
            expect(grid.columns[0].width).toEqual('500px');
            expect(grid.columns[3].width).toEqual('500px');
            expect(grid.columns[5].width).toEqual('500px');
            expect(grid.columns[10].width).toEqual('500px');
            expect(grid.columns[50].width).toEqual('500px');

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 50) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should render all records if height is explicitly set to null.', () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(20, 5);
            grid.height = null;
            fix.detectChanges();

            const recsCount = grid.data.length;

            // tbody should have height equal to all items * item height
            expect(grid.tbody.nativeElement.clientHeight).toEqual(recsCount * 50);
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should match width and height of parent container when width/height are set in %', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.outerWidth = 800;
            fix.componentInstance.outerHeight = 600;
            fix.componentInstance.grid.width = '50%';
            fix.componentInstance.grid.height = '50%';

            fix.detectChanges();

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');
            expect(grid.rowList.length).toBeGreaterThan(0);
        });

        it('should render 10 records if height is unset and parent container\'s height is unset', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it('should render 10 records if height is 100% and parent container\'s height is unset', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.grid.height = '700px';
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it(`should render all records exactly if height is 100% and parent container\'s height is unset and
            there are fewer than 10 records in the data view`, () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.grid.height = '100%';
            fix.componentInstance.data = fix.componentInstance.data.slice(0, 5);
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(200);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeFalsy();
            expect(fix.componentInstance.grid.rowList.length).toEqual(5);
        });

        it(`should render 10 records if height is 100% and parent container\'s height is unset and
            display density is changed`, () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.grid.height = '100%';
            fix.componentInstance.data = fix.componentInstance.data.slice(0, 11);
            fix.componentInstance.density = DisplayDensity.compact;
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css('.igx-grid__tbody')).styles.height;
            const defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBeGreaterThan(300);
            expect(defaultHeightNum).toBeLessThan(330);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toEqual(11);
        });

        it('should render correct columns if after scrolling right container size changes so that all columns become visible.', (done) => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '500px';
            fix.componentInstance.initColumnsRows(5, 5);

            fix.detectChanges();
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            const scrollbar = grid.parentVirtDir.getHorizontalScroll();
            scrollbar.scrollLeft = 10000;
            grid.width = '1500px';

            setTimeout(() => {
                fix.detectChanges();
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
                const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
                expect(headers.length).toEqual(5);
                for (let i = 0; i < headers.length; i++) {
                    expect(headers[i].context.column.field).toEqual(grid.columns[i].field);
                }
                done();
            }, 100);
        });

        it('Should render date and number values based on default formatting', () => {
            const fixture = TestBed.createComponent(IgxGridFormattingComponent);
            fixture.detectChanges();
             const grid = fixture.componentInstance.grid;
            const rows = grid.rowList.toArray();
             // verify default number formatting
            let expectedValue = '2,760';
            expect(rows[0].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1,098';
            expect(rows[5].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7,898';
            expect(rows[7].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
             // verify formatter function formatting
            expectedValue = '2.76e+3';
            expect(rows[0].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1.098e+3';
            expect(rows[5].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7.898e+3';
            expect(rows[7].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
             // verify date formatting
            expectedValue = 'Mar 21, 2005';
            expect(rows[0].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Jan 15, 2008';
            expect(rows[1].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Nov 20, 2010';
            expect(rows[2].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
             // verify summaries formatting
            let avgValue;
            let earliestValue;
            const summaries = fixture.debugElement.queryAll(By.css('.igx-grid-summary'));
            summaries.forEach((summary) => {
                const avgLabel = summary.query(By.css('[title=\'Avg\']'));
                const earliest = summary.query(By.css('[title=\'Earliest\']'));
                if (avgLabel) {
                    avgValue = avgLabel.nativeElement.nextSibling.innerText;
                    expect(avgValue).toBe('3,900.4');
                }
                if (earliest) {
                    earliestValue = earliest.nativeElement.nextSibling.innerText;
                    expect(earliestValue).toBe('May 17, 1990');
                }
            });
        });
    });

    describe('IgxGrid - keyboard navigation tests', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it('should allow pageup/pagedown navigation when the grid is focused', (done) => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            const pageDownKeyEvent = new KeyboardEvent('keydown', {
                code: 'PageDown',
                key: 'PageDown'
            });
            const pageUpKeyEvent = new KeyboardEvent('keydown', {
                code: 'PageUp',
                key: 'PageUp'
            });
            let currScrollTop;
            grid.width = '800px';
            grid.height = '500px';
            fix.componentInstance.initColumnsRows(25, 25);
            fix.detectChanges();
            grid.nativeElement.dispatchEvent(new Event('focus'));

            // testing the pagedown key
            grid.nativeElement.dispatchEvent(pageDownKeyEvent);
            grid.cdr.detectChanges();
            setTimeout(() => {
                currScrollTop = grid.verticalScrollContainer.getVerticalScroll().scrollTop;
                expect(currScrollTop).toEqual(grid.verticalScrollContainer.igxForContainerSize);

                // testing the pageup key
                grid.nativeElement.dispatchEvent(pageUpKeyEvent);
                grid.cdr.detectChanges();
                setTimeout(() => {
                    currScrollTop = grid.parentVirtDir.getHorizontalScroll().scrollTop;
                    expect(currScrollTop).toEqual(0);
                    done();
                }, 100);
            }, 0);
        });
    });

    describe('IgxGrid - API methods', () => {
        beforeEach(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule.forRoot()]
            }).compileComponents();
        }));

        it(`When edit a cell onto filtered data through grid method, the row should
            disapear and the new value should not persist onto the next row`, () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 5);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            const cols = fix.componentInstance.columns;
            const editValue = 0;

            grid.filter(cols[1].key, 2, IgxNumberFilteringOperand.instance().condition('greaterThan'));
            fix.detectChanges();
            grid.getCellByColumn(0, cols[1].key).update(editValue);
            fix.detectChanges();
            const gridRows = fix.debugElement.queryAll(By.css('igx-grid-row'));
            expect(gridRows.length).toEqual(1);
            const firstRowCells = gridRows[0].queryAll(By.css('igx-grid-cell'));
            const firstCellInputValue = firstRowCells[1].nativeElement.textContent.trim();
            expect(firstCellInputValue).toEqual('4');
        });
    });
});

@Component({
    template: `<div style="width: 800px; height: 600px;">
        <igx-grid #grid [data]="data" [autoGenerate]="autoGenerate" (onColumnInit)="columnCreated($event)">
            <igx-column *ngFor="let column of columns;" [field]="column.field" [hasSummary]="column.hasSummary"
                [header]="column.field" [width]="column.width">
            </igx-column>
        </igx-grid>
    </div>`
})
export class IgxGridTestComponent {
    public data: any[] = [{ index: 1, value: 1 }];
    public columns = [
        { field: 'index', header: 'index', dataType: 'number', width: null, hasSummary: false },
        { field: 'value', header: 'value', dataType: 'number', width: null, hasSummary: false }
    ];
    @ViewChild('grid') public grid: IgxGridComponent;

    public autoGenerate = false;

    public columnEventCount = 0;

    public columnCreated(column: IgxColumnComponent) {
        this.columnEventCount++;
        column.filterable = true;
        column.sortable = true;
    }

    public isHorizontalScrollbarVisible() {
        const scrollbar = this.grid.parentVirtDir.getHorizontalScroll();
        if (scrollbar) {
            return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
        }

        return false;
    }

    public getVerticalScrollHeight() {
        const scrollbar = this.grid.verticalScrollContainer.getVerticalScroll();
        if (scrollbar) {
            return parseInt(scrollbar.style.height, 10);
        }

        return 0;
    }

    public isVerticalScrollbarVisible() {
        const scrollbar = this.grid.verticalScrollContainer.getVerticalScroll();
        if (scrollbar) {
            return scrollbar.offsetHeight < scrollbar.children[0].offsetHeight;
        }
        return false;
    }

    public generateData(rows) {
        const d = [];
        for (let r = 0; r < rows; r++) {
            const record = {};
            for (let c = 0; c < this.columns.length; c++) {
                record[this.columns[c].field] = c * r;
            }
            d.push(record);
        }
        this.data = d;
    }

    public clearData() {
        this.data = [];
    }
}

@Component({
    template: `<igx-grid #grid [data]="data" (onColumnInit)="initColumns($event)">
        <igx-column *ngFor="let col of columns" [field]="col.key" [header]="col.key" [dataType]="col.dataType">
        </igx-column>
    </igx-grid>`
})
export class IgxGridDefaultRenderingComponent {
    public columns = [];
    public data = [];

    public changeInitColumns = false;

    @ViewChild('grid', { read: IgxGridComponent })
    public grid: IgxGridComponent;

    public initColumnsRows(rowsNumber: number, columnsNumber: number): void {
        this.columns = [];
        this.data = [];
        let i, j: number;
        for (i = 0; i < columnsNumber; i++) {
            this.columns.push({
                key: 'col' + i,
                dataType: 'number'
            });
        }
        for (i = 0; i < rowsNumber; i++) {
            const record = {};
            for (j = 0; j < columnsNumber; j++) {
                record[this.columns[j].key] = j * i;
            }
            this.data.push(record);
        }
    }

    public isHorizonatScrollbarVisible() {
        const scrollbar = this.grid.parentVirtDir.getHorizontalScroll();
        return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
    }

    public initColumns(column) {
        if (this.changeInitColumns) {
            switch (this.grid.columnList.length) {
                case 5:
                    if (column.index === 0 || column.index === 4) {
                        column.width = '200px';
                    }
                    break;
                case 30:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 25) {
                        column.width = '200px';
                    }
                    break;
                case 150:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 50) {
                        column.width = '500px';
                    }
                    break;
            }
        }
    }
}

@Component({
    template:
        `<div [style.width.px]="outerWidth" [style.height.px]="outerHeight">
            <igx-grid #grid [data]="data" [displayDensity]="density" [autoGenerate]="true"
                [paging]="paging" [perPage]="pageSize">
            </igx-grid>
        </div>`
})
export class IgxGridWrappedInContComponent extends IgxGridTestComponent {
    public data = [
        { 'ID': 'ALFKI', 'CompanyName': 'Alfreds Futterkiste' },
        { 'ID': 'ANATR', 'CompanyName': 'Ana Trujillo Emparedados y helados' },
        { 'ID': 'ANTON', 'CompanyName': 'Antonio Moreno Taquería' },
        { 'ID': 'AROUT', 'CompanyName': 'Around the Horn' },
        { 'ID': 'BERGS', 'CompanyName': 'Berglunds snabbköp' },
        { 'ID': 'BLAUS', 'CompanyName': 'Blauer See Delikatessen' },
        { 'ID': 'BLONP', 'CompanyName': 'Blondesddsl père et fils' },
        { 'ID': 'BOLID', 'CompanyName': 'Bólido Comidas preparadas' },
        { 'ID': 'BONAP', 'CompanyName': 'Bon app\'' },
        { 'ID': 'BOTTM', 'CompanyName': 'Bottom-Dollar Markets' },
        { 'ID': 'BSBEV', 'CompanyName': 'B\'s Beverages' },
        { 'ID': 'CACTU', 'CompanyName': 'Cactus Comidas para llevar' },
        { 'ID': 'CENTC', 'CompanyName': 'Centro comercial Moctezuma' },
        { 'ID': 'CHOPS', 'CompanyName': 'Chop-suey Chinese' },
        { 'ID': 'COMMI', 'CompanyName': 'Comércio Mineiro' },
        { 'ID': 'CONSH', 'CompanyName': 'Consolidated Holdings' },
        { 'ID': 'DRACD', 'CompanyName': 'Drachenblut Delikatessen' },
        { 'ID': 'DUMON', 'CompanyName': 'Du monde entier' },
        { 'ID': 'EASTC', 'CompanyName': 'Eastern Connection' },
        { 'ID': 'ERNSH', 'CompanyName': 'Ernst Handel' },
        { 'ID': 'FAMIA', 'CompanyName': 'Familia Arquibaldo' },
        { 'ID': 'FISSA', 'CompanyName': 'FISSA Fabrica Inter' },
        { 'ID': 'FOLIG', 'CompanyName': 'Folies gourmandes' },
        { 'ID': 'FOLKO', 'CompanyName': 'Folk och fä HB' },
        { 'ID': 'FRANK', 'CompanyName': 'Frankenversand' },
        { 'ID': 'FRANR', 'CompanyName': 'France restauration' },
        { 'ID': 'FRANS', 'CompanyName': 'Franchi S.p.A.' }
    ];

    public height = null;
    public paging = false;
    public pageSize = 5;
    public density = DisplayDensity.comfortable;
    public outerWidth = 800;
    public outerHeight: number;
}

@Component({
    template: `
        <igx-grid [data]="data" (onColumnInit)="columnCreated($event)">
            <igx-column field="ID"></igx-column>
            <igx-column field="Name"></igx-column>
        </igx-grid>
    `
})
export class IgxGridMarkupDeclarationComponent extends IgxGridTestComponent {
    public data = [
        { ID: 1, Name: 'Johny' },
        { ID: 2, Name: 'Sally' },
        { ID: 3, Name: 'Tim' }
    ];
    @ViewChild(IgxGridComponent, { read: IgxGridComponent })
    public instance: IgxGridComponent;
}

@Injectable()
export class LocalService {
    public records: Observable<any[]>;
    private _records: BehaviorSubject<any[]>;
    private dataStore: any[];

    constructor() {
        this.dataStore = [];
        this._records = new BehaviorSubject([]);
        this.records = this._records.asObservable();
    }

    public getData(data?: IForOfState, cb?: (any) => void): any {
        const size = data.chunkSize === 0 ? 10 : data.chunkSize;
        this.dataStore = this.generateData(data.startIndex, data.startIndex + size);
        this._records.next(this.dataStore);
        const count = 1000;
        if (cb) {
            cb(count);
        }
    }

    public generateData(start, end) {
        const dummyData = [];
        for (let i = start; i < end; i++) {
            dummyData.push({ Col1: 10 * i});
        }
        return dummyData;
    }
}

@Component({
    template: `
        <igx-grid [data]="data | async" (onDataPreLoad)="dataLoading($event)" [height]="'600px'">
            <igx-column [sortable]="true" [filterable]="true" [field]="'Col1'" [header]="'Col1'">
            </igx-column>
        </igx-grid>
    `,
    providers: [LocalService]
})
export class IgxGridRemoteVirtualizationComponent implements OnInit, AfterViewInit {
    public data;
    @ViewChild(IgxGridComponent, { read: IgxGridComponent })
    public instance: IgxGridComponent;
    constructor(private localService: LocalService, public cdr: ChangeDetectorRef) { }
    public ngOnInit(): void {
        this.data = this.localService.records;
    }

    public ngAfterViewInit() {
        this.localService.getData(this.instance.virtualizationState, (count) => {
            this.instance.totalItemCount = count;
            this.cdr.detectChanges();
        });
    }

    dataLoading(evt) {
        this.localService.getData(evt, () => {
            this.cdr.detectChanges();
        });
    }
}

@Component({
    template: GridTemplateStrings.declareGrid(
        '', '',
        `<igx-column field="ProductID" header="Product ID">
        </igx-column>
        <igx-column field="ProductName">
        </igx-column>
        <igx-column field="InStock" [dataType]="'boolean'">
        </igx-column>
        <igx-column field="UnitsInStock" [dataType]="'number'" [hasSummary]="true">
        </igx-column>
        <igx-column field="OrderDate" width="200px" [dataType]="'date'" [hasSummary]="true">
        </igx-column><igx-column field="UnitsInStock" [formatter]="formatNum" [dataType]="'number'" [hasSummary]="true">
        </igx-column>`)
})
export class IgxGridFormattingComponent extends BasicGridComponent {
    public data = SampleTestData.foodProductData();
    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
    public width = '600px';
    public height = '400px';
    public value: any;
     public formatNum() {
        return this.value.toExponential().toString();
    }
}
